# 文档说明

​	本文档记录本人对机器学习算法的理解。以面向实际问题为目的，不单纯讲解抽象公式为目的，分享给其他需要学习“机器学习”算法的人。本文档中数据、程序示例均来自互联网和其他书籍，如有错误请指正，以免误导他人，本文档会逐步更新、完善。本文档所有示例均用python3编写，为什么使用python语言，我谈谈我的感受。   

​	本人平时工作中以Java语言编程为主，对Java生态最熟悉，但我并不排斥其他语言，业余时间写一些感兴趣的小程序基本以C/C++、Python语言为主，算是一个C/C++/Java/Python混合开发者。我认为C/C++, Java跟Python都是非常成功的语言, 具体选哪种看你的场景。

**Python**：语法简单，更易上手，具有非常强大的第三方库，使得开发效率更高。但Python相对Java/C/C++来说，它的运行速度更慢。目前，由于大数据、人工智能（AI）的流行，Python 变得比以往更加流行，简单的语法和强大的数学库支持，对于算法编程更友好。



**Java**: 优美, 严谨, 健壮,不易出错。从语言设计上尽量避免了程序员犯错, 比如自动垃圾回收, 抛弃无符号类型, 安全的枚举, 编译期泛型检查等等。Java标准库和好多第三方代码都充斥着浓浓的设计感，比如最常见的IO操作：

Java:

```java
new BufferedInputStream(new FileInputStream(new File("filepath")))
```

C:

```c
fopen("filepath", "r")
```

Python:

```python
open("filepath")
```

​	对于懂Java的人，知道这是“装饰者”设计模式，觉得很厉害。不懂的人，觉得只是读一个文件还要写这么复杂，相比其他语言实在是啰嗦。由于Java的严谨、不易出错，Java 占据了世界上绝大部分电商、全融、通信等服务端应用开发。



**C/C++**：如果把Java/Python比作自动档汽车，那么C/C++就是一部手动挡汽车，现在虽然家用大部分都是自动档汽车，但专业赛车都是手动挡。C/C++程序能把性能发挥到极致，因此占据了世界上绝大部分贴近操作系统的硬件、数据库、偏底层中间件编程。



​	借用网友的话，Python是给人设计的, C/C++更像是为机器设计的,而Java则介于两者之间当然。用C++、Java也可以写算法，只是用Python对于初步理解算法、算法编程实现的初学者更友好，资料也比较丰富。这也是本文档选用Python语言的理由，不是其他语言不好，只为更适合。



# 基本概念

**分类**其实是从特定的数据中挖掘模式，作出判断的过程。比如Gmail邮箱里有垃圾邮件分类器，一开始的时候可能什么都不过滤，在日常使用过程中，我人工对于每一封邮件点选“垃圾”或“不是垃圾”，过一段时间，Gmail就体现出一定的智能，能够自动过滤掉一些垃圾邮件了。这是因为在点选的过程中，其实是给每一条邮件打了一个“标签”，这个标签只有两个值，要么是“垃圾”，要么“不是垃圾”，Gmail就会不断研究哪些特点的邮件是垃圾，哪些特点的不是垃圾，形成一些判别的模式，这样当一封信的邮件到来，就可以自动把邮件分到“垃圾”和“不是垃圾”这两个我们人工设定的分类的其中一个。    

 **聚类**的的目的也是把数据分类，但是事先我是不知道如何去分的，完全是算法自己来判断各条数据之间的相似性，相似的就放在一起。在聚类的结论出来之前，我完全不知道每一类有什么特点，一定要根据聚类的结果通过人的经验来分析，看看聚成的这一类大概有什么特点。

**有监督学习**：通过已有的训练样本去训练得到一个最优模型，再利用这个模型将所有的输入映射为相应的输出，对输出进行简单的判断从而实现预测和分类的目的，也就具有了对未知数据进行预测和分类的能力。

**无监督学习：**我们事先没有任何训练样本，而需要直接对数据进行建模。比如我们去参观一个画展，我们完全对艺术一无所知，但是欣赏完多幅作品之后，我们也能把它们分成不同的派别。无监督学习主要算法是聚类，聚类目的在于把相似的东西聚在一起。



# KNN

KNN(K-NearestNeighbor)，又称 K-近邻算法，是监督学习中的分类算法



## 实际问题

下表根据每部电影中搞笑镜头、拥抱镜头、打斗镜头的数量来标记电影类型。现在有一部新电影《唐人街探案》，电影中搞笑镜头、拥抱镜头、打斗镜头的数量分别为23、3、17。如何让机器根据之前电影类型的数据自动判别出电影类型？

| 电影名称     | 搞笑镜头 | 拥抱镜头 | 打斗镜头 | 被人工标记的类型 |
| ------------ | -------- | -------- | -------- | ---------------- |
| 宝贝当家     | 45       | 2        | 9        | 喜剧片           |
| 美人鱼       | 21       | 17       | 5        | 喜剧片           |
| 澳门风云3    | 54       | 9        | 11       | 喜剧片           |
| 功夫熊猫3    | 39       | 0        | 31       | 喜剧片           |
| 谍影重重     | 5        | 2        | 57       | 动作片           |
| 叶问3        | 3        | 2        | 65       | 动作片           |
| 伦敦陷落     | 2        | 3        | 55       | 动作片           |
| 我的特工爷爷 | 6        | 4        | 21       | 动作片           |
| 奔爱         | 7        | 46       | 4        | 爱情片           |
| 夜孔雀       | 9        | 39       | 8        | 爱情片           |
| 代理情人     | 9        | 38       | 2        | 爱情片           |
| 新步步惊心   | 8        | 34       | 17       | 爱情片           |

唐人街探案，搞笑镜头数量：23，拥抱镜头数量：3，打斗镜头数量：17，电影类型：？



## 原理

使用欧氏距离公式，计算两个向量点$x_A$ 和 $x_B$ 之间的距离：

d = $\sqrt{(xA_0 - xB_0)^2 + (xA_1 - xB_1)^2}$

例如，点(0,0)与(1,2)之间的距离计算为： $\sqrt{(1-0)^2 + (2-0)^2}$

如果数据集存在4个特征值，则点(1,0,0,1)与(7,6,9,4)之间的距离计算为:

 $\sqrt{(7-1)^2 + (6-0)^2 + (9-0)^2 + (4-1)^2}$



## 计算步骤

1.计算一个新样本与数据集中所有数据的距离

2.按照距离大小进行递增排序

3.选取距离最小的k个样本

4.确定前k个样本所在类别出现的频率，出现频率最高的类别为新样本类别



## 程序示例

```python

import numpy as np

def twoNodeDist(arr1, arr2):
    sum = 0
    for i in range(len(arr1)):
        sum += (arr1[i] - arr2[i])**2
    res = np.sqrt(sum)
    return res;

def createDataSet():
    #搞笑镜头、拥抱镜头、打斗镜头的数量
    dataSet = {"宝贝当家":[45,2,9,"喜剧片"],
               "美人鱼": [21, 17, 5, "喜剧片"],
               "澳门风云3": [54, 9, 11, "喜剧片"],
               "功夫熊猫3": [39, 0, 31, "喜剧片"],
               "谍影重重": [5, 2, 57, "动作片"],
               "叶问3": [3, 2, 65, "动作片"],
               "伦敦陷落": [2, 3, 55, "动作片"],
               "我的特工爷爷": [6, 4, 21, "动作片"],
               "奔爱": [7, 46, 4, "爱情片"],
               "夜孔雀": [9, 39, 8, "爱情片"],
               "代理情人": [9, 38, 2, "爱情片"],
               "新步步惊心": [8, 34, 17, "爱情片"]
               };
    return dataSet

def knn(ldataSet, dataPoint, k):
    res = {};
    #计算一个新样本与数据集中所有数据的距离
    for key,v in ldataSet.items():
        oneres = twoNodeDist(dataPoint, v)
        res[key] = [oneres, v[3]]
        
    #按照距离大小进行递增排序
    sres = sorted(res.items(), key=lambda item:item[1], reverse = False)
    
    #选取距离最小的k个样本
    r = {"动作片":0, "喜剧片":0, "爱情片":0}
    for v in sres[:k]:
        cou = r[v[1][1]]
        cou +=1
        r[v[1][1]] = cou
    
    #确定前k个样本所在类别出现的频率，出现频率最高的类别为新样本类别
    nr = sorted(r.items(), key=lambda item:item[1], reverse=True)
    
    print(nr[0][0])


ldataSet = createDataSet()
testData = {"唐人街探案": [23, 3, 17, "?"]}
dataPoint = list(testData.values())[0][:3]

knn(ldataSet, dataPoint, 4)


```

输出为：

```python
喜剧片
```



# K-Means

暂未编写

# 线性回归

## 一元



### 实际问题

下表为企业广告支出对销售收入的影响，当广告费为0时（不投入广告费），预测销售额为多少？当广告费为1000时，预测销售额为多少？

| 广告费（万元） | 销售额（万元） |
| -------------- | -------------- |
| 300            | 300            |
| 400            | 350            |
| 400            | 490            |
| 550            | 500            |
| 720            | 600            |
| 850            | 610            |
| 900            | 700            |
| 950            | 660            |



### 原理

一元线性回归方程为 y = ax + b，本文不讨论公式来源与推导，只为实际运用。需要根据数据计算出 a 和 b 的具体数值，则将目标数代入x ，便得到最终结果。



计算a的步骤：

$a = \frac{\Sigma(x_i - \bar x)(y_i - \bar y)}{\Sigma(x_i - \bar x)^2}$ ，不懂公式什么意思没关系，下面用实际数据代入公式，加深公式的理解。

公式中的x表示广告费数组 x = [300, 400, 400, 550, 720, 850, 900, 950]，$\bar x$表示数组x的平均数。

$\bar x$ = (300 + 400 + 400 + 550 + 720 + 850 + 900 + 950)/8 = 633.75

公式中的y表示销售额数组 y =  [300, 350, 490, 500, 600, 610, 700, 660]，$\bar y$表示数组y的平均数。

$\bar y$ = (300 + 350 + 490 + 500 + 600 + 610 + 700 + 660)/8 = 526.25



计算分子 $\Sigma(x_i - \bar x)(y_i - \bar y)$，$\Sigma$ 表示求和， $x_i$表示x数组中的每一个值，公式中的$y_i$表示y数组中的每一个值。

$\Sigma(x_i - \bar x)(y_i - \bar y)$ = (300 - 633.75) * (300 - 526.25) + 

​								  (400 - 633.75) * (350 - 526.25) +  

​								  (400 - 633.75) * (490 - 526.25) + 

​							      (550 - 633.75) * (500 - 526.25) +  

​								  (720 - 633.75) * (600 - 526.25) +  

​								  (850 - 633.75) * (610 - 526.25) +

​								  (900 - 633.75) * (700 - 526.25) +  

​								  (950 - 633.75) * (660 - 526.25)

​							   = (−333.75) * (−226.25) + (−233.75) * (−176.25) + (−233.75) * (−36.25) +

​								  (−83.75) * (−26.25) + (86.25 * 73.75) + (216.25 * 83.75) + 

​								  (266.25 * 173.75) + (316.25 * 133.75)

​							   =  75510.9375 + 41198.4375 + 8473.4375 + 2198.4375 + 

​									6360.9375 + 18110.9375 + 46260.9375 + 42298.4375

​							   = 240412.5



计算分母 $\Sigma(x_i - \bar x)^2$ ，$\Sigma$ 表示求和， $x_i$表示x数组中的每一个值。

$\Sigma(x_i - \bar x)^2$  = $(300 - 633.75)^2$ + $(400 - 633.75)^2$ + $(400 - 633.75)^2$ + $(550 - 633.75)^2$ +

​						$(720 - 633.75)^2$ + $(850 - 633.75)^2$ + $(900 - 633.75)^2$ + $(950 - 633.75)^2$

​					=  $(−333.75)^2$ + $(−233.75)^2$ + $(−233.75)^2$ + $(−83.75)^2$ +

​						$(86.25)^2$ + $(216.25)^2$ + $(266.25)^2$ + $(316.25)^2$

​					= 111389.0625 + 54639.0625 + 54639.0625 + 7014.0625 + 

​						7439.0625 + 46764.0625 + 70889.0625 + 100014.0625

​					= 452787.5

最终计算 $a = \frac{240412.5}{452787.5} \approx 0.531$  



计算b的步骤：$b = \bar y - a \bar x= 526.25 - 0.531*633.75 \approx 189.73 $

将a和b的值代入一元线性回归方程

$y = 0.53x + 189.73$

回到问题：当广告费为0时（不投入广告费），预测销售额为多少？当广告费为1000时，预测销售额为多少？

将0代入x，计算 y = 189.73

将1000代入x，计算 $y = 0.53 * 1000 + 189.73 = 719.73  $

当广告费为0时（不投入广告费），预测销售额约为189.73万。当广告费为1000万时，预测销售额约为 719.73万。



### 程序示例

```python
#x表示广告费数组
x = [300, 400, 400, 550, 720, 850, 900, 950]

#y表示销售额数组
y =  [300, 350, 490, 500, 600, 610, 700, 660]

#x数组平均数
x_mean = sum(x) / len(x)

#y数组平均数
y_mean = sum(y) / len(y)

#y = ax + b 根据数据计算a
#分子
molecule = 0.0
#分母
denominator = 0.0

for i in range(0, len(x)):
    molecule += (x[i] - x_mean) * (y[i] - y_mean)
    denominator += (x[i] - x_mean) ** 2
    
a = molecule/denominator
b = y_mean - a*x_mean

res1 = a*0 + b
res2 = a*1000 + b

print("广告费为0时的销售额为：", res1)
print("广告费为1000时的销售额为：", res2)
```

输出为：

```python
广告费为0时的销售额为： 189.75347155122432
广告费为1000时的销售额为： 720.7144631863732
```





## 多元



### 实际问题

下表为房屋出售的部分数据，现有一套房屋 地下室装饰面积：1277、建筑面积：16321、房屋质量等级：5、出售时房屋年龄：49，预测售价为？。

| 地下室装饰面积 | 建筑面积 | 房屋质量等级 | 出售时房屋年龄（年） | 售价（元） |
| -------------- | -------- | ------------ | -------------------- | ---------- |
| 706            | 8450     | 7            | 5                    | 208500     |
| 978            | 9600     | 6            | 31                   | 181500     |
| 486            | 11250    | 7            | 7                    | 223500     |
| 216            | 9550     | 7            | 91                   | 140000     |
| 655            | 14260    | 8            | 8                    | 250000     |
| 732            | 14115    | 5            | 16                   | 143000     |
| 1369           | 10084    | 8            | 3                    | 307000     |
| 859            | 10382    | 7            | 36                   | 200000     |
| 0              | 6120     | 7            | 77                   | 129900     |
| 851            | 7420     | 5            | 69                   | 118000     |
| 906            | 11200    | 5            | 43                   | 129500     |
| 998            | 11924    | 9            | 1                    | 345000     |
| 737            | 12968    | 5            | 46                   | 144000     |
| 0              | 10652    | 7            | 1                    | 279500     |
| 733            | 10920    | 6            | 48                   | 157000     |
| 0              | 6120     | 7            | 78                   | 132000     |
| 578            | 11241    | 6            | 40                   | 149000     |
| 0              | 10791    | 4            | 39                   | 90000      |
| 646            | 13695    | 5            | 4                    | 159000     |
| 504            | 7560     | 5            | 51                   | 139000     |
| 0              | 14215    | 8            | 1                    | 325300     |
| 0              | 7449     | 7            | 77                   | 139400     |
| 0              | 9742     | 8            | 6                    | 230000     |
| 840            | 4224     | 5            | 31                   | 129900     |
| 188            | 8246     | 5            | 42                   | 154000     |
| 0              | 14230    | 8            | 2                    | 256300     |
| 234            | 7200     | 5            | 59                   | 134800     |
| 1218           | 11478    | 5            | 49                   | 306000     |



### 原理

在一元线性回归中主要计算 a 和 b 这两个系数，多元线性回归计算系数为 $\hat{w} = (X^TX)^{-1}X^Ty$

$X$ 为已知数条件矩阵，$y$ 为已知数目标值矩阵。w上面的一个“帽”符号来表示它仅是 w 的一个最佳估计，可能并不
是数据中的真实 w 值。

在上面表格例子数据如取前三行，


$$
X = 
\begin{gathered}
\begin{Bmatrix} 706 & 8450 & 7 & 5 
			\\ 978 & 9600 & 6 & 31
            \\ 486 & 11250 & 7 & 7
\end{Bmatrix}

\end{gathered}
$$

$$
y = 
\begin{gathered}
\begin{Bmatrix} 208500 
			\\ 181500 
            \\ 223500 
\end{Bmatrix}

\end{gathered}
$$

公式中$X^T$ 表示 矩阵的转置，例如矩阵
$$
A = 
\begin{gathered}
\begin{Bmatrix} 1 & 2 & 0             
			\\ 3 & -1 & 4
\end{Bmatrix}
\end{gathered}
$$
的转置矩阵为
$$
A = 
\begin{gathered}
\begin{Bmatrix} 1 & 3                         
			 \\ 2 & -1
			 \\ 0 & 4
\end{Bmatrix}
\end{gathered}
$$
$矩阵^{-1}$ 为矩阵逆计算。





### 程序示例

```python
from numpy import *

def standRegres(xArr,yArr):
    xMat = mat(xArr); 
    yMat = mat(yArr).T
    xTx = xMat.T*xMat
    if linalg.det(xTx) == 0.0:
        print("This matrix is singular, cannot do inverse")
        return
    ws = xTx.I * (xMat.T*yMat)
    return ws

x = [[706, 8450, 7, 5],
     [978, 9600, 6, 31],
     [486, 11250, 7, 7],
     [216, 9550, 7, 91],
     [655, 14260, 8, 8],
     [732, 14115, 5, 16],
     [1369, 10084, 8, 3],
     [859, 10382, 7, 36],
     [0, 6120, 7, 77],
     [851, 7420, 5, 69],
     [906, 11200, 5, 43],
     [998, 11924, 9, 1],
     [737, 12968, 5, 46],
     [0, 10652, 7, 1],
     [733, 10920, 6, 48],
     [0, 6120, 7, 78],
     [578, 11241, 6, 40],
     [0, 10791, 4, 39],
     [646, 13695, 5, 4],
     [504, 7560, 5, 51],
     [0, 14215, 8, 1],
     [0, 7449, 7, 77],
     [0, 9742, 8, 6],
     [840, 4224, 5, 31],
     [188, 8246, 5, 42],
     [0, 14230, 8, 2],
     [234, 7200, 5, 59],
     [1218, 11478, 5, 49]]

y = [208500, 181500, 223500, 140000, 250000, 143000, 307000, 200000, 129900,
     118000, 129500, 345000, 144000, 279500, 157000, 132000, 149000, 90000,
     159000, 139000, 325300, 139400, 230000, 129900, 154000, 256300, 134800,
     306000]


ws = standRegres(x, y)
print("ws:")
print(ws)

z = mat([1277, 16321, 5, 49])
res = z*ws

print(res)
```

输出为：

```python
ws:
[[ 3.45397308e+01]
 [ 2.37661795e+00]
 [ 2.86220306e+04]
 [-9.68354986e+02]]
[[178556.77634335]]
```





# 朴素贝叶斯

朴素贝叶斯分类是一种十分简单的分类算法



## 实际问题

下表为课程销售情况，价格和课时长短两个因素影响销量。如果价格为“高”，课时为“多”，销量为？

| 价格     | 低     | 高     | 低     | 低     | 中     | 高     | 低     |
| -------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| **课时** | **多** | **中** | **少** | **中** | **中** | **少** | **少** |
| **销量** | **高** | **高** | **高** | **低** | **中** | **低** | **中** |



## 原理

一个包含7块石头的集合,分别有三个灰色石头和四个黑色石头，如果随机从中取一块石头,那么取到灰色石头的概率为3/7。类似地,取到黑色石头的概率为4/7，我们使用 P(gray) 来表示取到灰色石头的概率,其概率值可以通过灰色石头数目除以总的石头数目来得到。

如果将两块灰色石头和两块黑色石头放入A桶，再将一块灰色石头和两块黑色石头放入B桶，那么上述概率应该如何计算?计算 从B桶中取到灰色石头的概率的办法, 这就是所谓的条件概率 ( conditional probability)。假定计算的是从B桶取到灰色石头的概率,这个概率可以记作 P(gray|bucketB) ,称之为“在已知石头出自B桶的条件下,取出灰色石头的概率”。P(gray|bucketA)值为2/4, P(gray|bucketB) 的值为1/3。

条件概率的计算公式如下所示: P(gray|bucketB)=P(gray and bucketB) / P(bucketB)。首先,用B桶中灰色石头的个数除以两个桶中总的石头数,得到 P(gray and bucketB) = 1/7 。 其次,由于B桶中有3块石头,而总石头数为7,于是P(bucketB) 就等于3/7。于是有 P(gray|bucketB) = P(gray and bucketB)/P(bucketB) =(1/7) / (3/7) = 1/3。

**条件概率**：已知事件B出现的条件下A出现的概率，称为条件概率，记作：P(A|B)

条件概率计算公式：

当P(A)>0，P(B|A)=P(AB)/P(A)

当P(B)>0，P(A|B)=P(AB)/P(B)

另一种有效计算条件概率的方法称为贝叶斯准则。贝叶斯公式：

$P(B|A) = \frac{P(A|B)P(B)}{P(A)} $

换个表达式：

$P(类别|特征) = \frac{P(特征|类别)P(类别)}{P(特征)} $



**解上述问题**

要计算价格为“高”、课时为“多”的销量。



**计算价格各项概率**

价格数组 = [低,高,低,低,中,高,低]

分别计算 P(价格低)（价格低的概率），P(价格中)（价格中的概率），P(价格高)（价格高的概率）

$P(价格低) = \frac{4}{7}$

$P(价格中) = \frac{1}{7}$

$P(价格高) = \frac{2}{7}$



**计算课时各项概率**

课时数组 = [多,中,少,中,中,少,少]

分别计算 P(课时少)（课时少的概率），P(课时中)（课时中的概率），P(课时多)（课时多的概率）

$P(课时少) = \frac{3}{7}$

$P(课时中) = \frac{2}{7}$

$P(课时多) = \frac{1}{7}$



**计算销量各项概率**

销量数组 = [高,高,高,低,中,高,中]

分别计算 P(销量低)（销量低的概率），P(销量中)（销量低的概率），P(销量高)（销量高的概率）

$P(销量低) = \frac{2}{7}$

$P(销量中) = \frac{2}{7}$

$P(销量高) = \frac{3}{7}$



**根据贝叶斯公式，分别计算：**

**1.价格为“高”、课时为“多”时，销量为“低”的几率**

$P(销量低|价格高,课时多) = \frac{P(价格高|销量低) * P(课时多|销量低) * P(销量低)}{P(价格高) * P(课时多)} $

其中，$P(价格高|销量低) = P(价格高 and 销量低)/P(销量低) = (\frac{1}{7})/(\frac{2}{7}) = 0.5$

​		   $P(课时多|销量低) = P(课时多 and 销量低)/P(销量低) = 0/(\frac{2}{7}) = 0 $

$P(销量低|价格高,课时多) = \frac{0.5 * 0 * (\frac{2}{7})}{\frac{2}{7} * \frac{2}{7}} = 0$



**2.价格为“高”、课时为“多”时，销量为“中”的几率**

$P(销量中|价格高,课时多) = \frac{P(价格高|销量中) * P(课时多|销量中) * P(销量中)}{P(价格高) * P(课时多)} $

其中，$P(价格高|销量中) = P(价格高 and 销量中)/P(销量中) = 0/(\frac{2}{7}) = 0$

​		   $P(课时多|销量中) = P(课时多 and 销量中)/P(销量中) = 0/(\frac{2}{7}) = 0 $

$P(销量中|价格高,课时多) = \frac{0 * 0 * (\frac{2}{7})}{\frac{2}{7} * \frac{2}{7}} = 0$



**3.价格为“高”、课时为“多”时，销量为“高”的几率**

$P(销量高|价格高,课时多) = \frac{P(价格高|销量高) * P(课时多|销量高) * P(销量高)}{P(价格高) * P(课时多)} $

其中，$P(价格高|销量高) = P(价格高 and 销量高)/P(销量高) = (\frac{1}{7})/(\frac{3}{7}) = \frac{1}{3}$

​		   $P(课时多|销量高) = P(课时多 and 销量高)/P(销量高) = (\frac{1}{7})/(\frac{3}{7}) = \frac{1}{3} $

$P(销量高|价格高,课时多) = \frac{\frac{1}{3} * \frac{1}{3} * \frac{3}{7}}{\frac{2}{7} * \frac{1}{7}} = \frac{\frac{1}{21}}{\frac{2}{49}} = \frac{49}{42}$



**结果**

价格为“高”、课时为“多”时，销量为“高”的几率最大，销量预测结果为“高”





## 程序示例

```python
import numpy as py


def set_data(price, time, sale):
    price_number = []
    time_number = []
    sale_number = []
    
    for i in price:
        if i == "低":
            price_number.append(0)
        elif i == "中":
            price_number.append(1)
        elif i == "高":
            price_number.append(2)
            
    for j in time:
        if j == "少":
            time_number.append(0)
        elif j == "中":
            time_number.append(1)
        elif j == "多":
            time_number.append(2)
    
    for k in sale:
        if k == "低":
            sale_number.append(0)
        elif k == "中":
            sale_number.append(1)
        elif k == "高":
            sale_number.append(2)
    
    return price_number, time_number, sale_number

def native_bs(price_number, time_number, sale_number, expected_price, expected_time):
    price_p = []
    time_p = []
    sale_p = []

    for i in range(3):
        price_p.append(price_number.count(i) / len(price_number))
        time_p.append(time_number.count(i) / len(time_number))
        sale_p.append(sale_number.count(i) / len(sale_number))

    
    low_ex_sale = 0
    middle_ex_sale = 0
    high_ex_sale = 0
    
    for i in range(0, len(sale_number)):
        if sale_number[i] == 0:
            low_ex_sale += 1
        elif sale_number[i] == 1:
            middle_ex_sale += 1
        elif sale_number[i] == 2:
            high_ex_sale += 1
            
    
    aa = 0      #价格高|销量低
    bb = 0      #价格高|销量中
    cc = 0      #价格高|销量高
    for i in range(len(price_number)):
        if expected_price == price_number[i] and sale_number[i] == 0:
            aa += 1
        elif expected_price == price_number[i] and sale_number[i] == 1:
            bb += 1
        elif expected_price == price_number[i] and sale_number[i] == 2:
            cc += 1

    p_aa = aa/low_ex_sale           # p(价格高|销量低)
    p_bb = bb/middle_ex_sale        # p(价格高|销量中)
    p_cc = cc/high_ex_sale          # p(价格高|销量高)
    
    aaa = 0     #时间高|销量低
    bbb = 0     #时间高|销量中
    ccc = 0     #时间高|销量高
    for i in range(len(time_number)):
        if expected_time == time_number[i] and sale_number[i] == 0:
            aaa += 1
        elif expected_time == time_number[i] and sale_number[i] == 1:
            bbb += 1
        elif expected_time == time_number[i] and sale_number[i] == 2:
            ccc += 1
            
    p_aaa = aaa/low_ex_sale
    p_bbb = bbb/middle_ex_sale
    p_ccc = ccc/high_ex_sale
    
    fin_low_p = ( p_aa * p_aaa * sale_p[0] ) / (price_p[expected_price] * time_p[expected_time])
    fin_middle_p = ( p_bb * p_bbb * sale_p[1] ) / (price_p[expected_price] * time_p[expected_time])
    fin_high_p = ( p_cc * p_ccc * sale_p[2] ) / (price_p[expected_price] * time_p[expected_time])
    fin_list = [fin_low_p, fin_middle_p, fin_high_p]
    final_index = fin_list.index(max(fin_list))
    if final_index == 0:
        print("销量预测销量为低")
    elif final_index == 1:
        print("销量预测销量为中")
    else:
        print("销量预测销量为高")


price = ["低", "高", "低", "低", "中", "高", "低"]     #价格
time = ["多", "中", "少", "中", "中", "少", "少"]      #课时
sale = ["高", "高", "高", "低", "中", "低", "中"]      #销量

price_number, time_number, sale_number = set_data(price, time, sale)
print(price_number)

expected_price = 2
expected_time = 2

native_bs(price_number, time_number, sale_number, expected_price, expected_time)

```





# 决策树

暂未编写



# 逻辑回归

暂未编写



# Apriori

暂未编写

